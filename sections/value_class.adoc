== Value Class

Value classes have been around in Scala for a long time internally, and you've used them already many times because all Number's in Scala use this compiler trick to avoid boxing and unboxing numeric values from `int` to `scala.Int` etc. As a quick reminder, let's recall that `Array[Int]` is an actual JVM `int[]` (or for bytecode happy people, it's the JVM runtime type called: `[I`) which has tons of performance implications, but in one word -- arrays of numbers are fast, arrays of references not as much.

Ok, since we now know the compiler has fancy tricks to avoid boxing `int`s into `Int`s when it doesn't have to. Let's see how this feature is exposed for us, end users since Scala 2.10.x. The feature is called "value classes", is fairly simple to apply to your existing classes.

For our example let's implement a `Meter` which will serve as wrapper for plain `Int` and be able to convert the number of meters, into the number of type `Foot`. We need this class because no-one understands the crazy imperial units system ;-) On the downside though, why should we pay the runtime overhead of having an object around an `int` (that's quite a few bytes (!) per instance) if for 95% of the time we'll be using the plain meter value - because it's a project for the european market? Value classes to the rescue!

```scala
case class Meter(value: Double) extends AnyVal {
  def toFeet: Foot = Foot(value * 0.3048)
}

case class Foot(value: Double) extends AnyVal {
  def toMeter: Meter = Meter(value / 0.3048)
}
```

We'll be using Case (Value) Classes in all our examples here, but it's not technically required to do so (although very convinient). You could implement a Value Class using a normal class with one `val` parameter instead, but using case classes is usualy the best way to go. Why only one parameter you might ask -- this is because we'll try to avoid wrapping the value, and this only makes sense for single values, otherwise we'd have to keep a Tuple around somewhere, which gets fuzzy very quickly and we'd loose the performance of not-wrapping anyway. So remember - value classes work only for 1 value, although no-one said that that parameter must be a primitive (!), it can be a normal class, like `Fruit` or `Person`, we'll still be able to avoid wrapping it in the Value Class at some times.

TIP: All you need to do to define a Value Class is to have *a class with only one public val parameter*, if you don't the compiler will complain. That one parameter does _not_ have to be a primitive, it can be anything.

Bellow are a few examples of defining a Value Class:

```repl
// this fails:
scala> class A(a: Int) extends AnyVal
<console>:7: error: value class needs to have exactly one public val parameter

// this works
scala> class A(val a: Int) extends AnyVal
defined class A

// this works too, suggested style:
scala> case class A(a: Int) extends AnyVal
defined class A
```

Ok, so now that we got our `Meter` and `Foot` *Value Case Classes*, let's first examine how the generated bytecode has changes from a normal case class when we added the `extends AnyVal` part, making Meter a value class:

```repl
// case class
scala> :javap Meter
public class Meter extends java.lang.Object implements scala.Product,scala.Serializable{
    public double value();
    public Foot toFeet();

    // more here, but not interesting for us right now
}

scala> :javap Meter$
public class Meter$ extends scala.runtime.AbstractFunction1 implements scala.Serializable{
  // more gere, but not interesting for us right now
}


// case value class
scala> :javap Meter
Compiled from "<console>"
public final class Meter extends java.lang.Object implements scala.Product,scala.Serializable{
    public double value();
    public Foot toFeet();

   // in general, stayed the same as before
}

scala> :javap Meter$
public class Meter$ extends scala.runtime.AbstractFunction1 implements scala.Serializable{
    public final Foot toFeet$extension(double);

    // a few new methods appeared! All ending with $extension
}
```

WARNING: TODO TODO finishup explain extension methods and show example byte code of usage


